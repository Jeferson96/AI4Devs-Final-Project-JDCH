# **Architecture Requirements Document (ARD)**

## **1. Introducci√≥n**

### **1.1 Prop√≥sito del Documento**  
El prop√≥sito de este **Architecture Requirements Document (ARD)** es proporcionar una descripci√≥n detallada de la arquitectura del **MVP del Sistema de Agendamiento de Citas**. Este documento servir√° como referencia para el equipo de desarrollo, asegurando que el dise√±o y la implementaci√≥n del sistema sigan una estructura s√≥lida, escalable y alineada con los objetivos del negocio.  

### **1.2 Alcance de la Arquitectura**  
El alcance de este documento est√° limitado a la **arquitectura del MVP**, considerando los siguientes aspectos:  
- Implementaci√≥n de una plataforma de **agendamiento de citas** entre pacientes y profesionales.  
- Gesti√≥n de disponibilidad **manual** por parte de los profesionales.  
- Notificaciones por **correo electr√≥nico** para confirmaciones y recordatorios de citas.  
- Uso de tecnolog√≠as seleccionadas:  
  - **Backend:** NestJS  
  - **Frontend:** NextJS  
  - **Base de Datos:** PostgreSQL  
- Despliegue en un entorno de **alta disponibilidad** con enfoque en escalabilidad b√°sica.  

**Exclusiones del Alcance:**  
- No se abordar√° la integraci√≥n con **pasarelas de pago** ni con **calendarios externos**.  
- No se incluir√°n funcionalidades avanzadas como **reportes y m√©tricas**.  
- No se implementar√° un sistema de autenticaci√≥n de usuarios en esta fase.  

### **1.3 Objetivos y Consideraciones Claves**  
Los objetivos de la arquitectura del MVP incluyen:  
‚úÖ **Simplicidad y rapidez en la implementaci√≥n:** Dise√±ar un sistema ligero y funcional en el menor tiempo posible.  
‚úÖ **Escalabilidad futura:** Aunque es un MVP, la arquitectura debe permitir futuras mejoras sin cambios disruptivos.  
‚úÖ **Alta disponibilidad:** Garantizar un **99% de tiempo operativo**, asegurando confiabilidad en la gesti√≥n de citas.  
‚úÖ **Seguridad de los datos:** Cumplir con las mejores pr√°cticas en protecci√≥n de informaci√≥n personal y privacidad.  
‚úÖ **Facilidad de uso:** Asegurar que la experiencia de usuario sea intuitiva y accesible, cumpliendo con est√°ndares **WCAG**.  

---


## **2. Arquitectura General**  

### **2.1 Visi√≥n General del Sistema**  
El sistema de agendamiento de citas es una aplicaci√≥n **web** dise√±ada para facilitar la gesti√≥n de citas entre **pacientes y profesionales**. La arquitectura sigue un enfoque basado en **microservicios ligeros**, permitiendo modularidad y facilidad de escalabilidad en futuras iteraciones.  

El sistema se compone de tres capas principales:  
1. **Capa de Presentaci√≥n (Frontend - NextJS)**: Interfaz web accesible para pacientes y profesionales.  
2. **Capa de Aplicaci√≥n (Backend - NestJS)**: API REST responsable de la l√≥gica de negocio y gesti√≥n de datos.  
3. **Capa de Datos (PostgreSQL)**: Base de datos relacional encargada de almacenar informaci√≥n de citas y usuarios.  

üìå **Principios Arquitect√≥nicos Aplicados:**  
‚úÖ **Separaci√≥n de responsabilidades:** Distinci√≥n clara entre presentaci√≥n, l√≥gica y datos.  
‚úÖ **Escalabilidad modular:** Capacidad para agregar nuevas funcionalidades sin afectar la estabilidad.  
‚úÖ **Seguridad y disponibilidad:** Protecci√≥n de datos y operaci√≥n confiable con redundancia.  

### **2.2 Diagrama de Contexto (C4 - Nivel 1)**  
A continuaci√≥n, se presenta un **Diagrama de Contexto (Nivel 1)** que ilustra la relaci√≥n del sistema con sus usuarios y servicios externos:

```mermaid
graph TD;
    U1[Paciente] -->|Usa| S[Sistema de Agendamiento de Citas]
    U2[Profesional] -->|Usa| S
    S -->|Env√≠a correos| E[Servicio de Notificaci√≥n]
    S -->|Consulta y almacena| DB[(PostgreSQL)]
```

üìå **Explicaci√≥n:**  
- Los **pacientes y profesionales** interact√∫an con el sistema a trav√©s de la interfaz web.  
- El sistema se comunica con un **servicio de correo** para enviar notificaciones.  
- La base de datos almacena y recupera informaci√≥n sobre usuarios, citas y disponibilidad.  

### **2.3 Principales Componentes del Sistema**  
El sistema est√° compuesto por los siguientes m√≥dulos clave:

| **Componente**       | **Descripci√≥n** |
|----------------------|------------------------------------------------------|
| **Interfaz Web (NextJS)** | Plataforma para que los usuarios gestionen sus citas. |
| **API Backend (NestJS)** | Exposici√≥n de endpoints REST para manejar la l√≥gica del sistema. |
| **Base de Datos (PostgreSQL)** | Almac√©n de datos estructurados para la gesti√≥n de citas y usuarios. |
| **Servicio de Notificaciones** | Mecanismo de env√≠o de correos de confirmaci√≥n y recordatorios. |

### **2.4 Decisiones Arquitect√≥nicas Claves**  
üìå **Decisiones tomadas:**  
- Se opt√≥ por una **arquitectura basada en APIs REST** en lugar de GraphQL para simplicidad en el desarrollo del MVP.  
- Uso de **NextJS** en el frontend por su capacidad de renderizado h√≠brido y su compatibilidad con futuras mejoras.  
- Se eligi√≥ **PostgreSQL** debido a su estabilidad, capacidad de escalabilidad y soporte de integridad referencial.  
- Se dej√≥ abierta la posibilidad de migrar a **una arquitectura basada en eventos** en futuras iteraciones para mejorar el procesamiento as√≠ncrono.  

üìå **Trade-offs identificados:**  
- No se implementar√° autenticaci√≥n en el MVP, lo que limita la personalizaci√≥n de la experiencia del usuario.  
- Se usar√° una estructura monol√≠tica en el backend inicialmente, con la posibilidad de modularizar servicios en el futuro.  

---


# **3. Dise√±o de Componentes**  

## **3.1 Backend**  

El backend del sistema sigue una arquitectura basada en principios de **Domain-Driven Design (DDD)**, con una implementaci√≥n estructurada mediante **Hexagonal Architecture**, **Clean Architecture**, y utilizando enfoques como **Vertical Slicing** y **Screaming Architecture** para mejorar la mantenibilidad y escalabilidad del c√≥digo.  

### **3.1.1 Principios y Arquitecturas Aplicadas**  

üìå **Domain-Driven Design (DDD)**  
- El c√≥digo se organiza en **m√≥dulos de dominio**, reflejando los conceptos clave del negocio (Ej: `Appointments`, `Users`, `Availability`).  
- Cada m√≥dulo encapsula su l√≥gica de negocio, evitando dependencias innecesarias entre entidades.  

üìå **Hexagonal Architecture**  
- **Adaptadores y Puertos:**  
  - Se implementan puertos (`interfaces`) para separar la l√≥gica de negocio de las implementaciones concretas (Ej: persistencia de datos, servicios externos).  
  - Se definen adaptadores en la capa de infraestructura para manejar interacciones con servicios externos (Ej: notificaciones por email).  

üìå **Vertical Slicing**  
- Cada funcionalidad del sistema es **independiente y modular**, evitando la estructura tradicional en capas monol√≠ticas.  
- Se organizan las carpetas por **casos de uso**, en lugar de categor√≠as t√©cnicas.  

üìå **Screaming Architecture**  
- La estructura del c√≥digo refleja el **negocio**, no la tecnolog√≠a.  
- En lugar de carpetas gen√©ricas como `services`, `controllers`, se usan nombres como `Appointments`, `Users`, `Availability`.  

üìå **Clean Architecture**  
- Separaci√≥n estricta en **capas**:  
  - **Capa de dominio:** Define las entidades y l√≥gica de negocio.  
  - **Capa de aplicaci√≥n:** Contiene los casos de uso y reglas de aplicaci√≥n.  
  - **Capa de infraestructura:** Implementa adaptadores para bases de datos y servicios externos.  
  - **Capa de interfaz:** Expone la API a los clientes.  

üìå **SOLID & DRY Principles**  
- Se sigue **Single Responsibility Principle (SRP)** en cada m√≥dulo.  
- Se evita la duplicaci√≥n de c√≥digo con **reutilizaci√≥n de servicios** y patrones de dise√±o adecuados.  

---

### **3.1.2 Stack Tecnol√≥gico y Herramientas**  
- **Lenguaje:** TypeScript  
- **Framework:** NestJS  
- **ORM:** Prisma (para gestionar la base de datos con PostgreSQL)  
- **Validaci√≥n:** Zod (validaci√≥n de datos)  
- **Mensajer√≠a/Colas:** RabbitMQ (para procesamiento as√≠ncrono en el futuro)  
- **Autenticaci√≥n:** No incluida en el MVP, pero se prev√© JWT en versiones futuras  

---

### **3.1.3 Patrones de Dise√±o Implementados**  
| **Patr√≥n** | **Descripci√≥n** |
|------------|------------------------------------------------------|
| **Repository Pattern** | Separa la l√≥gica de acceso a datos de la l√≥gica de negocio. |
| **Dependency Injection** | Se utiliza el m√≥dulo de inyecci√≥n de dependencias de NestJS para mejorar testabilidad y modularidad. |
| **Factory Pattern** | Se usa para la creaci√≥n de objetos complejos en los casos de uso. |
| **Observer Pattern** | Utilizado para gestionar eventos internos, como notificaciones. |

---

## **3.2 Frontend**  

El frontend est√° desarrollado con **Next.js**, aprovechando su flexibilidad en **Server-Side Rendering (SSR)** y **Static Site Generation (SSG)** para mejorar la experiencia del usuario.  

### **3.2.1 Principales Flujos de Usuario**  
El sistema cuenta con los siguientes **flujos principales**, asegurando una experiencia fluida e intuitiva.  

| **Flujo** | **Descripci√≥n** |
|------------|------------------------------------------------------|
| **Appointment Booking** | El usuario selecciona un profesional, consulta la disponibilidad y agenda una cita. |
| **Appointment Management** | El usuario puede modificar o cancelar citas seg√∫n las reglas establecidas. |
| **Availability Management** | Los profesionales pueden definir sus horarios disponibles. |
| **Notifications Handling** | El sistema env√≠a correos electr√≥nicos de confirmaci√≥n y recordatorio de citas. |

üìå **Cada flujo de usuario se implementar√° con React Hooks y Context API para la gesti√≥n del estado global.**  

---

### **3.2.2 Componentes Claves del Frontend**  
üìå **Principales Componentes React:**  
- **AppointmentForm:** Formulario para agendar citas.  
- **AvailabilityManager:** Interfaz para que los profesionales configuren su disponibilidad.  
- **NotificationBanner:** Muestra confirmaciones y recordatorios de citas.  
- **UserDashboard:** Panel de control para pacientes y profesionales.  

üìå **Estado Global:**  
- Se usar√° **React Context API o Zustand** para manejar datos compartidos.  

---

## **3.3 Base de Datos**  

El sistema utilizar√° **PostgreSQL**, con un modelo relacional optimizado para la gesti√≥n de citas y disponibilidad. Se asegurar√° que el esquema cumpla con las normas de **normalizaci√≥n** para evitar redundancias y garantizar la consistencia de los datos.  

### **3.3.1 Entidades Principales**  

| **Entidad** | **Descripci√≥n** |
|------------|------------------------------------------------------|
| **Users** | Contiene datos de pacientes y profesionales. |
| **Appointments** | Registra la fecha, hora y estado de cada cita. |
| **Availability** | Gestiona los horarios disponibles de los profesionales. |
| **Notifications** | Registra los correos electr√≥nicos enviados a cada usuario. |
| **AuditLogs** | Permite registrar acciones relevantes para auditor√≠a. |

---

### **3.3.2 Modelo Relacional**  

```mermaid
erDiagram
    USERS ||--o{ APPOINTMENTS : has
    USERS ||--o{ AVAILABILITY : sets
    APPOINTMENTS ||--|{ NOTIFICATIONS : triggers
    USERS ||--o{ AUDITLOGS : logs
```

üìå **Explicaci√≥n del Modelo:**  
- Cada **usuario** puede tener m√∫ltiples **citas agendadas**.  
- Los **profesionales** gestionan su disponibilidad en la tabla `Availability`.  
- El sistema almacena **notificaciones enviadas** a los usuarios en la tabla `Notifications`.  
- Se implementa **`AuditLogs`** para registrar cambios en el sistema y garantizar trazabilidad.  

---

### **3.3.3 Estrategia de Indexaci√≥n y Optimizaci√≥n**  
- Se utilizar√°n **√≠ndices en columnas de b√∫squeda frecuente** (`id`, `user_id`, `appointment_date`).  
- Se emplear√°n **UUIDs en lugar de IDs autoincrementales** para mayor seguridad y escalabilidad.  
- Se aplicar√°n **constraints de integridad referencial** para evitar datos hu√©rfanos o inconsistencias.  

---

## **3.4 Sistema de Notificaciones**  

El sistema contar√° con un m√≥dulo de notificaciones basado en **Nodemailer** y **SendGrid**, con posibilidad de integraci√≥n futura con **WhatsApp API** o **Twilio** para SMS.  

### **3.4.1 Flujo de Env√≠o de Correos**  
1. El usuario agenda, modifica o cancela una cita.  
2. El backend **genera un evento** de notificaci√≥n.  
3. El servicio de notificaciones **procesa el evento** y env√≠a el correo electr√≥nico.  
4. Se almacena un **registro en la tabla `Notifications`** para trazabilidad.  

---


# **4. Modelado de Datos**  

## **4.1 Esquema de Base de Datos**  

La base de datos del sistema est√° dise√±ada con **PostgreSQL**, siguiendo un **modelo relacional** optimizado para la gesti√≥n eficiente de usuarios, citas y disponibilidad. Se ha aplicado **normalizaci√≥n** para evitar redundancias y asegurar integridad referencial.  

üìå **Caracter√≠sticas clave del modelo de datos:**  
‚úÖ **Uso de UUIDs** como identificadores primarios en todas las tablas.  
‚úÖ **√çndices en columnas de b√∫squeda frecuente** (`user_id`, `appointment_date`).  
‚úÖ **Relaciones bien definidas** con claves for√°neas y restricciones de integridad.  

---

## **4.2 Entidades y Relaciones**  

El modelo de datos est√° compuesto por las siguientes entidades principales:  

| **Entidad** | **Descripci√≥n** |
|------------|------------------------------------------------------|
| **Users** | Almacena la informaci√≥n de los usuarios (pacientes y profesionales). |
| **Appointments** | Registra las citas entre pacientes y profesionales. |
| **Availability** | Define la disponibilidad de los profesionales. |
| **Notifications** | Almacena las notificaciones enviadas a los usuarios. |
| **AuditLogs** | Guarda un registro de cambios y acciones en el sistema. |

### **Diagrama Relacional**  

```mermaid
erDiagram
    USERS ||--o{ APPOINTMENTS : has
    USERS ||--o{ AVAILABILITY : sets
    APPOINTMENTS ||--|{ NOTIFICATIONS : triggers
    USERS ||--o{ AUDITLOGS : logs
```

üìå **Explicaci√≥n de las relaciones:**  
- Un **usuario** puede tener m√∫ltiples **citas** con distintos profesionales.  
- Un **profesional** define su disponibilidad en la tabla `Availability`.  
- Cada acci√≥n relacionada con citas **genera una notificaci√≥n** para el usuario.  
- Todos los eventos relevantes del sistema **se registran en `AuditLogs`**.  

---

## **4.3 Normalizaci√≥n y Optimizaci√≥n**  

### **4.3.1 Estrategia de Normalizaci√≥n**  
El esquema se ha dise√±ado para cumplir con la **Tercera Forma Normal (3NF)**, asegurando que:  
‚úÖ No haya **datos redundantes** innecesarios.  
‚úÖ Cada columna almacene un **√∫nico valor at√≥mico**.  
‚úÖ Se utilicen **claves for√°neas** para garantizar integridad de datos.  

---

### **4.3.2 Optimizaci√≥n del Rendimiento**  
üìå **√çndices Clave:**  
- **B√∫squedas de citas:** Index en `appointment_date` para mejorar consultas por fecha.  
- **Usuarios y autenticaci√≥n futura:** Index en `email` para facilitar validaciones r√°pidas.  

üìå **Estrategias de Escalabilidad:**  
- **Particionamiento de tablas** en el futuro para manejar grandes vol√∫menes de datos.  
- **Almacenamiento de logs en una base de datos secundaria** para optimizar consultas en producci√≥n.  

---


# **5. Seguridad y Privacidad**  

## **5.1 Principios de Seguridad Aplicados**  

La seguridad del sistema se basa en las mejores pr√°cticas para proteger la informaci√≥n de los usuarios y garantizar la integridad de los datos. Se han definido los siguientes principios clave:  

üìå **Principios de Seguridad en el Desarrollo:**  
‚úÖ **Principio de Menor Privilegio:** Cada usuario solo tendr√° acceso a los datos y funciones necesarias.  
‚úÖ **Defensa en Profundidad:** Se aplican m√∫ltiples capas de seguridad para mitigar riesgos.  
‚úÖ **Principio de Seguridad por Dise√±o:** La seguridad es considerada desde la arquitectura, no como un agregado posterior.  
‚úÖ **Reglas de Validaci√≥n Rigurosas:** Se validan y sanitizan todos los datos de entrada para evitar inyecciones y ataques comunes.  

---

## **5.2 Protecci√≥n de Datos Personales**  

El sistema manejar√° informaci√≥n sensible de los usuarios, por lo que se han implementado las siguientes medidas para garantizar la privacidad de los datos:  

üìå **Medidas de Protecci√≥n:**  
- **Cifrado en Reposo:** Los datos sensibles almacenados en la base de datos (ej. correos electr√≥nicos) estar√°n cifrados con **AES-256**.  
- **Cifrado en Tr√°nsito:** Todo el tr√°fico de datos entre el cliente y el servidor estar√° cifrado mediante **TLS 1.3**.  
- **Cumplimiento con GDPR & OWASP:** Se seguir√°n recomendaciones de seguridad para proteger datos personales.  
- **Pol√≠tica de Retenci√≥n de Datos:** Se definir√°n reglas para eliminar o anonimizar datos obsoletos.  

---

## **5.3 Controles de Acceso y Autenticaci√≥n**  

Aunque el **MVP** no implementar√° autenticaci√≥n de usuarios, se define una estructura para futuras versiones con autenticaci√≥n segura.  

üìå **Modelo de Acceso en el Futuro:**  
- **JWT con Refresh Tokens:** Para autenticaci√≥n basada en tokens.  
- **OAuth 2.0 & OpenID Connect:** Para futuras integraciones con proveedores externos.  
- **Roles y Permisos Basados en RBAC:** Diferenciaci√≥n de permisos entre pacientes y profesionales.  

---

## **5.4 Estrategias contra Ataques Comunes**  

Para proteger el sistema contra amenazas externas, se han implementado las siguientes estrategias de mitigaci√≥n:  

| **Ataque Potencial** | **Medidas de Protecci√≥n** |
|--------------------|----------------------------------|
| **SQL Injection** | Uso de **ORM Prisma**, validaci√≥n estricta de entradas y consultas parametrizadas. |
| **Cross-Site Scripting (XSS)** | Escapado de datos en el frontend y sanitizaci√≥n de entradas con **Zod**. |
| **Cross-Site Request Forgery (CSRF)** | Implementaci√≥n de tokens CSRF en futuras versiones. |
| **Denegaci√≥n de Servicio (DoS/DDoS)** | Limitaci√≥n de peticiones con **rate-limiting** en la API. |
| **Exposici√≥n de Datos Sensibles** | No se almacenar√°n contrase√±as en texto plano, y se usar√° **bcrypt** en futuras versiones. |

---

# **6. Escalabilidad y Disponibilidad**  

## **6.1 Estrategias de Escalabilidad**  

El sistema debe ser capaz de manejar un crecimiento progresivo en la cantidad de usuarios y transacciones sin comprometer el rendimiento. Para ello, se han definido las siguientes estrategias de escalabilidad:  

üìå **Escalabilidad Horizontal y Vertical:**  
‚úÖ **Escalabilidad Horizontal:** Se pueden a√±adir m√°s instancias de los servicios backend y frontend para distribuir la carga.  
‚úÖ **Escalabilidad Vertical:** Aumento de recursos en el servidor de base de datos en funci√≥n del crecimiento del sistema.  

üìå **Bases de Datos Optimizadas para Escalabilidad:**  
‚úÖ **Uso de Prisma ORM** para manejar grandes vol√∫menes de datos con consultas optimizadas.  
‚úÖ **Indexaci√≥n Estrat√©gica** en columnas de b√∫squeda frecuente (`appointment_date`, `user_id`).  
‚úÖ **Particionamiento de Tablas** en futuras versiones para optimizar consultas de gran escala.  

üìå **Desacoplamiento de Servicios:**  
‚úÖ Uso de **colas de mensajes (RabbitMQ o Redis Pub/Sub)** en versiones futuras para manejar procesos as√≠ncronos como notificaciones.  
‚úÖ Microservicios planificados a futuro para manejar m√≥dulos de citas y disponibilidad por separado.  

---

## **6.2 Balanceo de Carga y Distribuci√≥n de Tr√°fico**  

Para garantizar una experiencia de usuario fluida, se implementar√°n estrategias de distribuci√≥n de tr√°fico.  

üìå **Estrategias de Balanceo de Carga:**  
‚úÖ **Reverse Proxy con Nginx o Traefik** para distribuir tr√°fico entre m√∫ltiples instancias del backend.  
‚úÖ **Load Balancer (AWS ALB o Nginx HA)** para repartir tr√°fico entre servidores en futuras iteraciones.  

üìå **CDN para el Frontend:**  
‚úÖ Uso de **Vercel o Cloudflare CDN** para servir archivos est√°ticos y reducir latencia en el frontend.  

üìå **Optimizaci√≥n de Respuesta en la API:**  
‚úÖ Uso de **caching en Redis** para almacenar respuestas frecuentes y reducir carga en la base de datos.  
‚úÖ **Rate Limiting** en la API para evitar abuso del sistema y ataques DoS.  

---

## **6.3 Monitoreo y Mantenimiento**  

Para garantizar un **99% de disponibilidad**, se aplicar√°n estrategias de monitoreo continuo.  

üìå **Estrategias de Monitoreo:**  
‚úÖ **Logging Centralizado** con **Winston + ELK Stack** (Elasticsearch, Logstash, Kibana).  
‚úÖ **Alertas y Notificaciones** con Prometheus + Grafana o AWS CloudWatch.  
‚úÖ **Sistemas de Monitoreo de Errores** con Sentry o Datadog.  

üìå **Plan de Recuperaci√≥n ante Fallos:**  
‚úÖ **Backups autom√°ticos de la base de datos** con retenci√≥n configurable.  
‚úÖ **Tolerancia a fallos en el backend** con reinicios autom√°ticos (PM2 o Kubernetes).  
‚úÖ **Rollback Autom√°tico en despliegues** para mitigar fallos en nuevas versiones.  

---


# **7. Diagramas de Arquitectura**  

## **7.1 Casos de Uso**  

El siguiente diagrama representa los **principales casos de uso** del sistema, detallando las interacciones entre los usuarios y el sistema de agendamiento de citas.  

```mermaid
graph TD;
    A[Paciente] -->|Agenda Cita| B(Sistema de Agendamiento)
    A -->|Cancela Cita| B
    A -->|Modifica Cita| B
    B -->|Env√≠a Notificaci√≥n| C[Servicio de Notificaciones]
    B -->|Actualiza Disponibilidad| D[Profesional]
    D -->|Configura Horario| B
    B -->|Consulta Base de Datos| E[(PostgreSQL)]
```

üìå **Explicaci√≥n:**  
- **El paciente** puede agendar, modificar o cancelar citas.  
- **El sistema** actualiza la base de datos y env√≠a notificaciones a los usuarios.  
- **El profesional** configura su disponibilidad, que es utilizada por el sistema para la gesti√≥n de citas.  

---

## **7.2 Diagramas C4 (Niveles 1 y 2)**  

### **Diagrama C4 - Nivel 1 (Contexto del Sistema)**  

```mermaid
graph TD;
    U1[Paciente] -->|Usa| S[Sistema de Agendamiento]
    U2[Profesional] -->|Usa| S
    S -->|Env√≠a correos| E[Servicio de Notificaci√≥n]
    S -->|Consulta y almacena| DB[(PostgreSQL)]
```

üìå **Explicaci√≥n:**  
- Representa c√≥mo el **sistema** interact√∫a con los usuarios y servicios externos.  
- Se considera **PostgreSQL** como base de datos y un servicio externo para **notificaciones por correo**.  

### **Diagrama C4 - Nivel 2 (Componentes del Sistema)**  

```mermaid
graph TD;
    Frontend -->|Consume API| Backend
    Backend -->|Consulta y guarda| DB[(PostgreSQL)]
    Backend -->|Env√≠a correos| Notifications[Servicio de Notificaciones]
    Backend -->|Maneja disponibilidad| Availability[Disponibilidad de Profesionales]
```

üìå **Explicaci√≥n:**  
- **Frontend:** Next.js se comunica con la API para realizar operaciones.  
- **Backend:** NestJS gestiona la l√≥gica de negocio y acceso a datos.  
- **Base de datos:** PostgreSQL almacena usuarios, citas y disponibilidad.  
- **Servicio de Notificaciones:** Maneja el env√≠o de correos electr√≥nicos.  

---

## **7.3 Modelo de Base de Datos**  

El modelo de datos ha sido actualizado para incluir detalles de **columnas, tipos de datos, llaves primarias y for√°neas, y relaciones**.  

```mermaid
erDiagram
    USERS {
        uuid id PK
        string first_name
        string last_name
        string email UNIQUE
        string role ENUM('PATIENT', 'PROFESSIONAL')
        timestamp created_at
        timestamp updated_at
    }
    
    APPOINTMENTS {
        uuid id PK
        uuid patient_id FK -> USERS.id
        uuid professional_id FK -> USERS.id
        timestamp appointment_date
        string status ENUM('SCHEDULED', 'CANCELLED', 'COMPLETED')
        timestamp created_at
        timestamp updated_at
    }

    AVAILABILITY {
        uuid id PK
        uuid professional_id FK -> USERS.id
        timestamp available_date
        time start_time
        time end_time
        boolean is_booked DEFAULT FALSE
        timestamp created_at
        timestamp updated_at
    }

    NOTIFICATIONS {
        uuid id PK
        uuid user_id FK -> USERS.id
        uuid appointment_id FK -> APPOINTMENTS.id
        string type ENUM('CONFIRMATION', 'REMINDER', 'CANCELLATION')
        boolean is_sent DEFAULT FALSE
        timestamp sent_at
    }

    AUDIT_LOGS {
        uuid id PK
        uuid user_id FK -> USERS.id
        string action
        json metadata
        timestamp created_at
    }

    USERS ||--o{ APPOINTMENTS : has
    USERS ||--o{ AVAILABILITY : manages
    APPOINTMENTS ||--|{ NOTIFICATIONS : triggers
    USERS ||--o{ AUDIT_LOGS : logs
```

üìå **Explicaci√≥n del modelo de datos:**  
- **USERS**: Almacena informaci√≥n de pacientes y profesionales.  
- **APPOINTMENTS**: Registra las citas entre pacientes y profesionales, con estados definidos.  
- **AVAILABILITY**: Gestiona la disponibilidad de los profesionales.  
- **NOTIFICATIONS**: Registra los correos electr√≥nicos enviados.  
- **AUDIT_LOGS**: Registra eventos relevantes del sistema.  

---

## **7.4 Diagrama de Secuencia**  

Este diagrama describe el proceso de **agendamiento de una cita**.  

```mermaid
sequenceDiagram
    participant Patient as Paciente
    participant Frontend as Frontend
    participant Backend as Backend API
    participant DB as Base de Datos
    participant Email as Servicio de Notificaciones

    Patient->>Frontend: Selecciona fecha y hora
    Frontend->>Backend: Env√≠a solicitud de agendamiento
    Backend->>DB: Valida disponibilidad
    DB-->>Backend: Respuesta de disponibilidad
    Backend->>DB: Guarda cita en la base de datos
    Backend->>Email: Env√≠a notificaci√≥n de confirmaci√≥n
    Email-->>Patient: Recibe confirmaci√≥n por correo
```

---

## **7.5 Diagrama de Flujo**  

```mermaid
graph TD;
    A[Profesional accede a la plataforma] --> B[Selecciona disponibilidad]
    B --> C{¬øEst√° disponible el horario?}
    C -- No --> D[Mostrar mensaje de error]
    C -- S√≠ --> E[Guardar disponibilidad en la base de datos]
    E --> F[Confirmaci√≥n enviada al profesional]
```

---

## **7.6 Dise√±o del Sistema y Arquitectura de Alto Nivel**  

El siguiente diagrama muestra la **arquitectura de alto nivel** del sistema, reflejando los principales componentes y sus interacciones.  

```mermaid
graph TD;
    subgraph Frontend
        A1[Next.js - UI Web]
    end
    
    subgraph Backend
        B1[NestJS - API REST]
        B2[Services Layer]
        B3[Domain Layer]
        B4[Infrastructure Layer]
    end
    
    subgraph Database
        C1[PostgreSQL]
    end
    
    subgraph External Services
        D1[Email Notification Service]
    end

    A1 -->|HTTP Requests| B1
    B1 -->|Business Logic| B2
    B2 -->|Domain Rules| B3
    B3 -->|Data Access| B4
    B4 -->|CRUD Operations| C1
    B1 -->|Triggers Notifications| D1
```

üìå **Explicaci√≥n:**  
- **Frontend (Next.js)**: Interfaz web para pacientes y profesionales.  
- **Backend (NestJS)**: Gestiona la l√≥gica de negocio y procesamiento de datos.  
- **Base de Datos (PostgreSQL)**: Almacena citas, disponibilidad y usuarios.  
- **Servicio Externo (Notificaciones)**: Maneja el env√≠o de correos electr√≥nicos.  

---


# **8. Integraciones y Dependencias Externas**  

## **8.1 Servicios de Correo Electr√≥nico**  

Para el manejo de notificaciones autom√°ticas, el sistema integrar√° un **servicio de correo electr√≥nico**.  

üìå **Opciones Evaluadas:**  
‚úÖ **SendGrid**: Escalable y f√°cil de integrar con NestJS.  
‚úÖ **Nodemailer**: Alternativa para entornos auto-gestionados.  

üìå **Eventos que activan una notificaci√≥n:**  
1. **Confirmaci√≥n de cita:** Cuando un paciente agenda una cita.  
2. **Recordatorio de cita:** Env√≠o autom√°tico antes de la cita programada.  
3. **Modificaci√≥n de cita:** Notificaci√≥n de cambios en la fecha/hora.  
4. **Cancelaci√≥n de cita:** Mensaje al paciente y profesional.  

üìå **Estrategia de Env√≠o:**  
‚úÖ Se implementar√° una **cola de procesamiento** con RabbitMQ o Redis para manejar el env√≠o as√≠ncrono y evitar bloqueos en el sistema.  

---

## **8.2 API Externas (Futuras Integraciones)**  

El MVP no incluir√° integraciones con servicios externos, pero se han definido puntos de extensi√≥n para futuras mejoras.  

üìå **Integraciones Evaluadas para Futuras Versiones:**  
‚úÖ **Calendarios Externos (Google Calendar, Outlook API):** Sincronizaci√≥n autom√°tica de citas.  
‚úÖ **Pasarelas de Pago (Stripe, PayPal):** Procesamiento de pagos online para consultas pagadas.  
‚úÖ **Mensajer√≠a (WhatsApp API, Twilio):** Recordatorios de citas mediante SMS o WhatsApp.  

üìå **Estrategia de Implementaci√≥n en Futuras Versiones:**  
- Se definir√°n **webhooks** para sincronizaci√≥n en tiempo real.  
- Se establecer√° una **capa de abstracci√≥n** para facilitar cambios en proveedores de servicio.  

---

## **8.3 Consideraciones para la Integraci√≥n de Calendarios**  

Para garantizar una integraci√≥n eficiente con **Google Calendar** o **Outlook API** en el futuro, se han definido los siguientes aspectos:  

üìå **Requisitos T√©cnicos:**  
‚úÖ Uso de **OAuth 2.0** para autenticaci√≥n de usuarios con sus cuentas de calendario.  
‚úÖ Implementaci√≥n de **webhooks** para actualizaciones en tiempo real.  
‚úÖ Conversi√≥n de citas del sistema a **eventos compatibles con el formato iCalendar**.  

üìå **Beneficios de la Integraci√≥n:**  
- Sincronizaci√≥n autom√°tica de las citas con calendarios personales.  
- Reducci√≥n de conflictos de agenda para profesionales.  

---


# **9. Plan de Despliegue e Infraestructura**  

## **9.1 Infraestructura y Entorno de Producci√≥n**  

El sistema ser√° desplegado en una infraestructura en la nube que garantice **alta disponibilidad, escalabilidad y seguridad**.  

üìå **Componentes de la Infraestructura:**  
‚úÖ **Frontend:** Desplegado en **Vercel** o **AWS S3 con CloudFront CDN** para optimizar la entrega de contenido.  
‚úÖ **Backend:** Desplegado en **AWS EC2, DigitalOcean o Render**, utilizando contenedores Docker.  
‚úÖ **Base de Datos:** **PostgreSQL en AWS RDS, Supabase o DigitalOcean Managed Databases** con backups autom√°ticos.  
‚úÖ **Servicio de Notificaciones:** Manejado con **SendGrid o AWS SES**.  
‚úÖ **Cache y Cola de Procesamiento:** Redis en AWS Elasticache o Upstash para mejorar rendimiento.  

üìå **Modelo de Implementaci√≥n:**  
- **Entorno de Desarrollo:** Local y staging en servidores temporales.  
- **Entorno de Producci√≥n:** Infraestructura gestionada con Docker + Kubernetes (en futuras versiones).  

---

## **9.2 Estrategia de Despliegue y CI/CD**  

Para garantizar actualizaciones sin interrupciones, se implementar√° un pipeline de **CI/CD (Continuous Integration / Continuous Deployment)**.  

üìå **Herramientas de CI/CD:**  
‚úÖ **GitHub Actions o GitLab CI/CD:** Para ejecutar pruebas y validar el c√≥digo antes del despliegue.  
‚úÖ **Docker + Kubernetes:** Orquestaci√≥n de contenedores en futuras versiones.  
‚úÖ **Blue-Green Deployment:** Estrategia para evitar tiempos de inactividad en producci√≥n.  

üìå **Flujo de Despliegue:**  
1. **Commit en GitHub/GitLab:** El c√≥digo es subido al repositorio.  
2. **Pruebas Autom√°ticas:** Se ejecutan tests unitarios y de integraci√≥n.  
3. **Build & Containerizaci√≥n:** Generaci√≥n de im√°genes Docker para backend y frontend.  
4. **Despliegue Autom√°tico:** La nueva versi√≥n se lanza en un entorno staging.  
5. **Validaci√≥n Manual:** Se revisan logs y errores antes del lanzamiento a producci√≥n.  
6. **Promoci√≥n a Producci√≥n:** Se activa la nueva versi√≥n sin interrupci√≥n del servicio.  

---

## **9.3 Mecanismos de Recuperaci√≥n ante Fallos**  

Para garantizar la estabilidad del sistema, se han definido estrategias de recuperaci√≥n en caso de fallos.  

üìå **Estrategias de Resiliencia:**  
‚úÖ **Backups Autom√°ticos:** Copias diarias de la base de datos con retenci√≥n configurable.  
‚úÖ **Rollback en Despliegues:** Implementaci√≥n de **feature flags** para deshacer cambios si se detectan errores.  
‚úÖ **Monitoreo Activo:** Uso de herramientas como **Prometheus + Grafana** o **AWS CloudWatch**.  
‚úÖ **Escalabilidad Autom√°tica:** Uso de **Auto Scaling Groups** en AWS para aumentar recursos en caso de alta demanda.  

üìå **Manejo de Errores y Recuperaci√≥n:**  
- **Errores Cr√≠ticos en Producci√≥n:** Reinicio autom√°tico con PM2 o Kubernetes.  
- **P√©rdida de Datos:** Restauraci√≥n desde backups en menos de 15 minutos.  
- **Ca√≠da del Servicio:** Redirecci√≥n de tr√°fico a servidores de respaldo.  

---


# **10. Decisiones Clave y Trade-offs**  

## **10.1 Justificaci√≥n de la Arquitectura Seleccionada**  

El dise√±o arquitect√≥nico del sistema se basa en principios de **modularidad, escalabilidad y mantenibilidad**. Las siguientes decisiones han sido tomadas para garantizar un balance entre **rapidez de desarrollo** y **capacidad de expansi√≥n** en futuras versiones.  

üìå **Decisiones Claves:**  
‚úÖ **NestJS como framework backend**: Facilita la modularidad y aplica buenas pr√°cticas como inyecci√≥n de dependencias.  
‚úÖ **Next.js para el frontend**: Ofrece SSR e ISR, mejorando la performance y SEO.  
‚úÖ **PostgreSQL como base de datos**: Garantiza escalabilidad y consistencia en datos relacionales.  
‚úÖ **ORM Prisma**: Simplifica el manejo de datos y asegura integridad referencial.  
‚úÖ **RabbitMQ / Redis para procesamiento as√≠ncrono** (planeado para futuras versiones).  
‚úÖ **Infraestructura basada en contenedores (Docker)**: Facilita la portabilidad y escalabilidad.  

---

## **10.2 Evaluaci√≥n de Alternativas Consideradas**  

| **Tecnolog√≠a / Enfoque** | **Alternativa Evaluada** | **Decisi√≥n Tomada** | **Justificaci√≥n** |
|--------------------------|------------------------|------------------|------------------|
| **Backend Framework** | Express.js | ‚ùå No Usado | NestJS ofrece mejor estructura y escalabilidad. |
| **Frontend Framework** | React (SPA) | ‚úÖ Usado (Next.js) | Next.js mejora SEO y performance con SSR. |
| **Base de Datos** | MySQL | ‚ùå No Usado | PostgreSQL tiene mejor soporte para JSON y transacciones. |
| **ORM** | TypeORM | ‚ùå No Usado | Prisma tiene mejor tipado y validaci√≥n de datos. |
| **Mensajer√≠a** | Kafka | üöß Evaluado para futuras versiones | RabbitMQ es m√°s adecuado para notificaciones y colas simples. |
| **Autenticaci√≥n** | Firebase Auth | üöß Evaluado para futuras versiones | Se planea implementar JWT/OAuth2 m√°s adelante. |

---

## **10.3 Aspectos a Mejorar en Futuras Iteraciones**  

El MVP se enfoca en la funcionalidad base del sistema, pero se han identificado mejoras para futuras versiones.  

üìå **√Åreas de mejora planeadas:**  
üöÄ **Implementaci√≥n de autenticaci√≥n (JWT / OAuth2)** para acceso seguro.  
üöÄ **Sincronizaci√≥n con calendarios externos (Google Calendar, Outlook)**.  
üöÄ **Soporte para pagos online (Stripe, PayPal, MercadoPago)**.  
üöÄ **Optimizaci√≥n del procesamiento de notificaciones con RabbitMQ**.  
üöÄ **Migraci√≥n a una arquitectura basada en eventos (Event-Driven Architecture)** para mejorar rendimiento en escalabilidad.  

---

# **11. Criterios de √âxito y Validaci√≥n**  

## **11.1 Definici√≥n de √âxito del MVP**  

El **MVP del sistema de agendamiento de citas** ser√° considerado exitoso si cumple con los siguientes criterios:  

üìå **Funcionalidad Operativa:**  
‚úÖ Los pacientes pueden **agendar, modificar y cancelar citas** correctamente.  
‚úÖ Los profesionales pueden **gestionar su disponibilidad** sin errores.  
‚úÖ El sistema env√≠a **notificaciones autom√°ticas** de confirmaci√≥n y recordatorio.  

üìå **Estabilidad y Disponibilidad:**  
‚úÖ **99% de disponibilidad** en el entorno de producci√≥n.  
‚úÖ No debe haber **errores cr√≠ticos** que impidan la operaci√≥n normal del sistema.  
‚úÖ **Tiempo de respuesta** en la API menor a **500ms** en condiciones normales.  

üìå **Experiencia de Usuario y Accesibilidad:**  
‚úÖ La interfaz debe ser **intuitiva y f√°cil de usar**.  
‚úÖ Cumplimiento con est√°ndares de **accesibilidad web (WCAG 2.1)**.  

üìå **Escalabilidad y Seguridad:**  
‚úÖ El sistema debe poder **manejar al menos 500 citas diarias** sin degradaci√≥n del rendimiento.  
‚úÖ Todos los datos deben estar **cifrados en tr√°nsito y en reposo**.  

---

## **11.2 Pruebas de Integraci√≥n y Carga**  

Para validar el desempe√±o del sistema, se realizar√°n **pruebas automatizadas** antes del lanzamiento.  

üìå **Tipos de Pruebas Aplicadas:**  

| **Tipo de Prueba** | **Objetivo** | **Herramientas** |
|--------------------|-------------|-----------------|
| **Pruebas Unitarias** | Validar m√≥dulos individuales del backend y frontend. | Jest, Testing Library |
| **Pruebas de Integraci√≥n** | Asegurar la correcta comunicaci√≥n entre los componentes del sistema. | Cypress, Postman |
| **Pruebas de Carga** | Evaluar la respuesta del sistema bajo alto tr√°fico. | k6, JMeter |
| **Pruebas de Seguridad** | Detectar vulnerabilidades y ataques comunes. | OWASP ZAP, Burp Suite |
| **Pruebas de Usabilidad** | Asegurar que la experiencia del usuario sea intuitiva. | Entrevistas y pruebas con usuarios reales |

---

## **11.3 Estrategias de Validaci√≥n con Usuarios**  

El sistema ser√° validado con usuarios reales antes de su lanzamiento completo.  

üìå **Plan de Validaci√≥n:**  
‚úÖ **Prueba Beta con un grupo cerrado de profesionales y pacientes**.  
‚úÖ **Recopilaci√≥n de feedback** para mejoras en la interfaz y flujo de usuario.  
‚úÖ **Monitoreo en tiempo real** del uso del sistema para detectar problemas tempranos.  
‚úÖ **Optimizaci√≥n iterativa basada en m√©tricas de uso**.  

---
